import icons 

import {
  // Basic UI Icons
  Cpu, Layers, Image as ImageIcon, Type, FileOutput, HelpCircle,
  ChevronDown, ChevronRight, LayoutList, SquarePlus, FileImage, Shuffle,
  Search, PlusCircle, Paintbrush, Text, Frame, Triangle, RectangleHorizontal, Circle,
  // Additional Lucide Icons matching your new UI
  User, // for Face Control
  Aperture, // for Pose Control
  Sun, // for Lighting
  Eye, // for Depth Control
  SquareStack, // for Layers or Segments
  Grid, // for Grids/References
  RefreshCw, // for Re-rendering tools
  Scissors, // for Remove Background
  ArrowUp, ArrowDown, // for Import/Export
  Wand2, // for AI-based Tools
  Compass, // for Navigation / Scene control
  Ruler, // for Inpainting/Outpainting
  ZoomIn, ZoomOut, // for scaling
  Settings, Upload, Download, RotateCw, PlayCircle
} from 'lucide-react';





left sidebar data

const insertCategories: NodeCategory[] = [
  {
    name: 'Controllers',
    icon: Compass,
    options: [
      {
        design: 'normal-node',
        functionality: 'control-net',
        type: 'control-net-pose',
        label: 'Pose Control',
        icon: Aperture,
        description: 'Control pose of the subject',
      },
      {
        design: 'normal-node',
        functionality: 'control-net',
        type: 'control-net-edge',
        label: 'Edge Control',
        icon: Ruler,
        description: 'Edge detection via Canny map',
      },
      {
        design: 'normal-node',
        functionality: 'control-net',
        type: 'control-net-lights',
        label: 'Light Control',
        icon: Sun,
        description: 'Custom lighting map control',
      },
      {
        design: 'normal-node',
        functionality: 'control-net',
        type: 'control-net-face',
        label: 'Face Control',
        icon: User,
        description: 'Facial expressions and identity',
      },
      {
        design: 'normal-node',
        functionality: 'control-net',
        type: 'control-net-segments',
        label: 'Segments',
        icon: SquareStack,
        description: 'Segment maps for regions',
      },
      {
        design: 'normal-node',
        functionality: 'control-net',
        type: 'control-net-depth',
        label: 'Depth Control',
        icon: Eye,
        description: 'Depth map control for composition',
      },
      {
        design: 'normal-node',
        functionality: 'control-net',
        type: 'control-net-reference',
        label: 'Reference',
        icon: Grid,
        description: 'Reference faces, styles, or objects',
      },
    ],
  },
  {
    name: 'Re-rendering',
    icon: RefreshCw,
    options: [
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-re-imagine',
        label: 'Re-Imagine',
        icon: Wand2,
        description: 'Recreate image with new style',
      },
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-re-scene',
        label: 'Re-Scene',
        icon: Compass,
        description: 'Change scene and object context',
      },
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-object-relight',
        label: 'Re-Light',
        icon: Sun,
        description: 'Change the lighting of the scene',
      },
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-reangle',
        label: 'Re-Angle',
        icon: RotateCw,
        description: 'Change the camera angle',
      },
    ],
  },
  {
    name: 'Tools',
    icon: Settings,
    options: [
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-removebg',
        label: 'Remove BG',
        icon: Scissors,
        description: 'Erase image background',
      },
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-upscale',
        label: 'Upscale',
        icon: ZoomIn,
        description: 'Increase image resolution',
      },
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-inpainting',
        label: 'In-Painting',
        icon: Ruler,
        description: 'Fill missing areas in the image',
      },
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-inpainting',
        label: 'Out-Painting',
        icon: Ruler,
        description: 'Extend content beyond original image',
      },
      {
        design: 'normal-node',
        functionality: 'input',
        type: 'input-text',
        label: 'Text Prompt',
        icon: Text,
        description: 'Input text prompt for generation',
      },
      {
        design: 'normal-node',
        functionality: 'image-to-image',
        type: 'image-to-image-merger',
        label: 'Merger',
        icon: Layers,
        description: 'Merge multiple images with weights',
      },
      {
        design: 'custom-router',
        functionality: 'helper',
        type: 'connector',
        label: 'Router',
        icon: Share2,
        description: 'Route connections in workflows',
      },
    ],
  },
  {
    name: 'Render',
    icon: FileOutput,
    options: [
      {
        design: 'image-node',
        functionality: 'preview',
        type: 'preview-image',
        label: 'Image Output',
        icon: ImageIcon,
        description: 'Final rendered image',
      },
      {
        design: 'image-node',
        functionality: 'preview',
        type: 'preview-realtime',
        label: 'Real-Time Preview',
        icon: PlayCircle,
        description: 'Live preview during generation',
      },
    ],
  },
];


options design
{activeTab === 'Insert' && !searchTerm && (
    <div className="">
        {insertCategories.map((category) => (
        <div key={category.name} className="mb-8">
            <div className="text-sm font-semibold text-gray-600 mb-2 flex items-center">
            <category.icon className="h-4 w-4 mr-2" />
            {category.name}
            </div>
            <div className="grid grid-cols-2 gap-2">
            {category.options.map(option => (
                <div 
                key={option.type}
                onClick={() => handleAddNode(option.type)}
                className="bg-neutral-900 rounded-lg flex flex-col items-center justify-center py-6 px-4 cursor-pointer hover:bg-neutral-800 transition-colors"
                >
                <option.icon className="h-6 w-6 text-gray-400 mb-1" />
                <span className="text-xs text-center text-gray-400 font-medium">{option.label}</span>
                </div>
            ))}
            </div>
        </div>
        ))}
    </div>
)}




old side bar tab selector and search bar


      {/* Tab selector */}
      <div className="flex border-b border-gray-700 bg-sidebar-accent">
        <button 
          className={`flex-1 py-3 px-2 text-center text-sm font-medium ${activeTab === 'Outline' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400 hover:text-gray-300'}`}
          onClick={() => setActiveTab('Outline')}
        >
          <div className="flex flex-col items-center justify-center">
            <LayoutList className="h-5 w-5 mb-1" />
            <span className="hidden lg:inline">Outline</span>
          </div>
        </button>
        <button 
          className={`flex-1 py-3 px-2 text-center text-sm font-medium ${activeTab === 'Insert' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400 hover:text-gray-300'}`}
          onClick={() => setActiveTab('Insert')}
        >
          <div className="flex flex-col items-center justify-center">
            <SquarePlus className="h-5 w-5 mb-1" />
            <span className="hidden lg:inline">Insert</span>
          </div>
        </button>
        <button 
          className={`flex-1 py-3 px-2 text-center text-sm font-medium ${activeTab === 'Assets' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400 hover:text-gray-300'}`}
          onClick={() => setActiveTab('Assets')}
        >
          <div className="flex flex-col items-center justify-center">
            <FileImage className="h-5 w-5 mb-1" />
            <span className="hidden lg:inline">Assets</span>
          </div>
        </button>
      </div>
      
      {/* Search bar */}
      <div className="p-2 border-b border-gray-700">
        <div className="relative">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-gray-500" />
          <Input 
            type="text"
            placeholder="Search components..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full pl-8 bg-gray-800 border-gray-700 text-sm h-9"
          />
        </div>
      </div>




what i am essentially trying to achieve is to build a reordering logic to sort the nodes in a manner that when given to ReactFlow it decides their depths on the canvas. same logic to layering panel to photoshop. the current left sidebar logic works, however it might not be the most robust or reliable logic found. I will give you the left sidebar code and the logic of adding new node on canvas and need you to investigate if there will be scenarios of colliding node orders(depth in canvas) or other scenarios where an unexpected issue could occur.

some current issues I need to fix:

1-reordering of depth works most of the times, but sometimes it doesn't
2-when I reorder, the grouped child nodes inside labeled frame suddenly moves or gets ungrouped (despite in the useCanvasStore state it is still grouped)
3-investigate more possilbe occurring issues with the current logic of reordering and assigning new order to newly placed nodes
4-use the sortablejs library for the leftsidebar panel or other library, and don't use dnd library
5-enhance the logic of grouping child nodes into the labeledFrameNode and fix the order incase the child node's order is smaller than the labeledframegroup node



old labeled frame group node logic 

// ðŸ§¹ Group node into a labeled frame and adjust z-index/order
const groupNodeIntoLabel = (childId, labelId) => {
  if (childId === labelId) {
    console.warn("Cannot group a label node inside itself!");
    return;
  }

  const nodes = getNodes();
  const labelNode = nodes.find(n => n.id === labelId);
  const childNode = nodes.find(n => n.id === childId);

  if (!labelNode || !childNode) {
    console.warn("Label or child node not found!");
    return;
  }

  // Get max order of existing children
  const currentChildren = nodes.filter(n => n.parentId === labelId);
  
  const maxChildOrLabelOrder = currentChildren.length > 0
    ? Math.max(...currentChildren.map(n => n.data?.order ?? 0)) + 1
    : (labelNode.data?.order ?? 0) + 1;
  
  const highestNodeOrder = getHighestOrder(nodes)
  const newChildOrder = highestNodeOrder > maxChildOrLabelOrder ? highestNodeOrder : maxChildOrLabelOrder; //could be used for order as well
  
  // Get the entire subtree of the child (if it has children)
  const subtree = getSubtree(childId, nodes);
  
  // Update all nodes in the subtree
  const updatedNodes = nodes.map(node => {
    if (subtree.some(n => n.id === node.id)) {
      return {
        ...node,
        parentId: node.id === childId ? labelId : node.parentId,
        extent: node.id === childId ? 'parent' : node.extent,
        data: {
          ...node.data,
          order: newChildOrder - (node.id === childId ? 0 : 0.001) // Slightly offset children
        }
      };
    }
    return node;
  });

  setNodes(updatedNodes);
  console.log(`Grouped ${childId} into ${labelId} with order ${newChildOrder}`);
};

console.log(nodes)

// ðŸ§² Handle drag stop and check for frame containment
const onNodeDragStop = (event, node) => {
  const nodes = reactFlowInstance.getNodes();
  const labelNodes = nodes.filter(n => n.type === 'labeledFrameGroupNode');

  const nodeBounds = {
    x: node.position.x,
    y: node.position.y,
    width: node.width ?? 100,
    height: node.height ?? 50,
  };
  const nodeCenter = {
    x: nodeBounds.x + nodeBounds.width / 2,
    y: nodeBounds.y + nodeBounds.height / 2,
  };

  let grouped = false;

  for (const labelNode of labelNodes) {
    const labelBounds = {
      x: labelNode.position.x,
      y: labelNode.position.y,
      width: labelNode.width ?? 300,
      height: labelNode.height ?? 200,
    };

    const isInside =
      nodeCenter.x >= labelBounds.x &&
      nodeCenter.x <= labelBounds.x + labelBounds.width &&
      nodeCenter.y >= labelBounds.y &&
      nodeCenter.y <= labelBounds.y + labelBounds.height;

    if (isInside) {
      groupNodeIntoLabel(node.id, labelNode.id);
      grouped = true;
      break;
    }
  }

  if (!grouped) {
    // Reset parent and order if not grouped into any frame
    useCanvasStore.getState().updateNodeData(node.id, {
      parentId: null,
      extent: undefined,
      data: {
        ...node.data,
        order: 0, // Or reset to a default order
      }
    });
    console.log(`Node ${node.id} reset to top level`);
  }
};


 const organizeHierarchy = () => {
    const parentToChildrenMap: Record<string, Node[]> = {};
    const childrenSet = new Set<string>();

    const getBounds = (node: Node) => ({
      x: node.position.x,
      y: node.position.y,
      width: node.width ?? 100,
      height: node.height ?? 100,
      area: (node.width ?? 100) * (node.height ?? 100),
    });

    // ðŸ”— Edge-based grouping (as-is)
    canvasEdges.forEach(edge => {
      const source = canvasNodes.find(n => n.id === edge.source);
      const target = canvasNodes.find(n => n.id === edge.target);
      if (source && target) {
        if (!parentToChildrenMap[target.id]) parentToChildrenMap[target.id] = [];
        if (!parentToChildrenMap[target.id].some(n => n.id === source.id)) {
          parentToChildrenMap[target.id].push(source);
        }
        childrenSet.add(source.id);
      }
    });

    // ðŸ  Explicit parentId grouping (NEW!)
    canvasNodes.forEach(node => {
      if (node.parentId) {
        const parent = canvasNodes.find(n => n.id === node.parentId);
        if (parent) {
          if (!parentToChildrenMap[parent.id]) parentToChildrenMap[parent.id] = [];
          if (!parentToChildrenMap[parent.id].some(n => n.id === node.id)) {
            parentToChildrenMap[parent.id].push(node);
            childrenSet.add(node.id);
          }
        }
      }
    });

    // ðŸ”¢ Ordering nodes by 'order' (for non-grouped nodes)
    const orderedNodes = [...canvasNodes]
      .filter(n => !childrenSet.has(n.id))
      .sort((a, b) => (b.data?.order ?? 0) - (a.data?.order ?? 0));
    
    return { topLevelNodes: orderedNodes, parentToChildrenMap };
  };


  const handleDragEnd = ({ active, over }) => {
    if (!active || !over || active.id === over.id) return;

    const { topLevelNodes, parentToChildrenMap } = organizeHierarchy();
    const nodes = useCanvasStore.getState().nodes;

    const findSubtree = (nodeId, subtree = []) => {
      const node = nodes.find(n => n.id === nodeId);
      if (node) subtree.push(node);
      const children = parentToChildrenMap[nodeId] || [];
      children.forEach(child => findSubtree(child.id, subtree));
      return subtree;
    };

    // Create a flat list of all nodes
    const flatList = [...topLevelNodes];
    Object.keys(parentToChildrenMap).forEach(parentId => {
      parentToChildrenMap[parentId].forEach(child => {
        if (!flatList.includes(child)) flatList.push(child);
      });
    });

    // Build a mapping of nodeId to its subtree or just itself
    const nodeToSubtree = {};
    flatList.forEach(node => {
      if (parentToChildrenMap[node.id]) {
        nodeToSubtree[node.id] = findSubtree(node.id);
      } else if (!Object.values(parentToChildrenMap).flat().some(n => n.id === node.id)) {
        nodeToSubtree[node.id] = [node]; // Independent node
      }
    });

    // Rebuild the ordered list
    const oldIndex = flatList.findIndex(n => n.id === active.id);
    const newIndex = flatList.findIndex(n => n.id === over.id);
    const updatedList = [...flatList];

    const [movedNodes] = updatedList.splice(oldIndex, 1);
    const subtree = nodeToSubtree[active.id] || [movedNodes];
    updatedList.splice(newIndex, 0, ...subtree);

    // Deduplicate by node ID
    const deduped = [];
    const seen = new Set();
    updatedList.forEach(node => {
      if (!seen.has(node.id)) {
        deduped.push(node);
        seen.add(node.id);
      }
    });

    // Update orders
    deduped.map((node, idx) => {
      node.data = { ...node.data, order: deduped.length - idx };
    });

    setNodes(deduped);
  };


rive light input old code:
{[1, 2, 3, 4].map((i) => {
            const { lightGetters, lightSetters } = lightControls(i);
            const ref = lightValuesRef(i);
            
            // console.log(ref)
            
            return (
              <div key={i} className="p-2 border border-gray-700 rounded-lg">
                <div className="mb-4 flex items-center justify-between w-full">
                  <label className="text-md text-[#9e9e9e]">Select Light {i}</label>
                  <input
                    type="checkbox"
                    checked={lightGetters.selected ?? false}
                    onChange={(e) => {
                      lightSetters.setSelected(e.target.checked);
                      onChangeLightValue(i, "selected", e.target.checked);
                    }}
                  />
                </div>

                {["size", "width", "power"].map((key) => (
                  <div key={key} className="mb-4 flex items-center justify-between w-full">
                    <label className="text-md text-[#9e9e9e]">{key} {i}</label>
                      
                      <div className="flex items-center">
                        <input
                          value={`${ref?.[key] ?? 100}%`}
                          type="text"
                          className="mr-2 text-sm text-center w-[60px] h-[30px] rounded-full bg-[#191919] border border-[#2a2a2a]"
                        />
                        <CustomSlider
                          value={ref?.[key] ?? 100}
                          min={0}
                          max={100}
                          step={1}
                          onChange={(val) => {
                            lightSetters[`set${key.charAt(0).toUpperCase() + key.slice(1)}`](val);
                            onChangeLightValue(i, key, val);
                          }}
                        />
                      </div>
                  </div>
                ))}

                <div className="mb-4 flex items-center justify-between w-full">
                  <label className="text-md text-[#9e9e9e]">Color {i}</label>
                  <input
                    type="color"
                    value={ref?.color ?? "#ffffff"}
                    onChange={(e) => {
                      const { r, g, b } = hexToRGB(e.target.value);
                      // console.log(r,g,b)
                      lightSetters.setRgb(r,g,b);
                      onChangeLightValue(i, "color", e.target.value);
                    }}
                    className="w-[30px] h-[30px] p-0 border-none bg-transparent rounded-full"
                  />
                </div>
              </div>
            );
          })}